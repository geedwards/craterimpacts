# -*- coding: utf-8 -*-
"""planetsfinal.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RcPOrCnnqcCXO4jen8w4a2yLa5QL6UPc
"""

# Commented out IPython magic to ensure Python compatibility.
import math
import numpy as np
# %matplotlib inline
import matplotlib.pyplot as plt
import matplotlib.image as img
import matplotlib.colors as clrs
import matplotlib

class Crater:
  """Container for information on all the craters on the field at a given time, 
  and whether they've been covered up."""
  def __init__(self, xin, yin, rin):
    """A crater has a position in x and y and a radius, and the rest of the 
    properties can be calculated from there"""
    self.x = xin
    self.y = yin
    self.r = rin
    # Must keep track of the current area as well as the original area to tell 
    # whether the crater has been covered yet.
    self.area = math.pi*rin ** 2
    self.area0 = math.pi*rin ** 2
    self.exists = True

  def updateExists(self):
    # Every time the crater is covered, check whether this means it's been 
    # covered enough to not be counted anymore
    if self.area < 0.01*self.area0:
      self.exists = False

  def reduceArea(self, c):
    # Run this when another crater appears on the board
    d = math.sqrt((self.x - c.x) ** 2+(self.y - c.y) ** 2)
    n1 = (self.r ** 2 - c.r ** 2 + d ** 2)/(2*d)
    # If the crater is too far away to cover up this one, no need to run the rest
    if d >= c.r + self.r or abs(n1 **2 > self.r **2):
      return self.exists
    # If it's exactly on top of the current crater, the area is simple subtraction
    elif math.isclose(self.x, c.x) & math.isclose(self.y, c.y):
       if self.r < c.r:
         self.area = 0
       else:
         self.area = self.area - c.area
       self.updateExists()
       return self.exists
    # Otherwise, use this formula to figure out how much area has been covered.
    else:
        n2 = math.sqrt(self.r ** 2 - n1 ** 2)
        self.area = self.area - (self.r ** 2 * math.asin(n2/self.r) + c.r ** 2*math.asin(n2/c.r) - n2*(n1 + math.sqrt(c.r ** 2 - self.r ** 2 + n1 ** 2)))
        self.updateExists()
        return self.exists


#######################################
# Helper functions
#######################################
def checkSaturation(craters, a_total, threshold=0.9):
  """Check whether the area covered by craters exceeds the threshold of
  saturation of the total area.
  craters: A list of crater objects
  a_total: The total area being checked
  threshhold: decimal number representing the fraction of area required to 
  consider the area saturated. 
  Return: [whether the area is saturated, the total area covered by craters]"""
  crater_area = 0
  for i in range(len(craters)):
    crater_area = crater_area + craters[i].area
  # Check if the area is above the saturation threshold
  if crater_area >= threshold*a_total:
    return [True,crater_area]
  else:
    return [False,crater_area]
  
def reduceAll(craters, newcrater):
  # THis has been the real slower downer. Oh well
  for i in craters:
      i.reduceArea(newcrater)

def countValidCraters(craters):
  numExist = 0
  for i in craters:
    if i.exists:
      numExist += 1

  return numExist

def removeNonExist(craters):
  """Take out all the craters that have been completely covered up."""
  for i in craters:
    if not i.exists:
      craters.remove(i)

    
# Now that Crater objects are set up, get a script to plot
# While the area isn't saturated, continue to add craters
t = 0; # Time variable in units of thousands of years
# For the first part, the radius is constant. Uncomment that line to replicate
# r = 5; # km
# For the second part, I will use a random number generator to find out what 
# The radius should be
r = np.random.exponential(scale=4)+5 # km
# Generate a random location
x = np.random.rand()*500
y = np.random.rand()*500
# Change this to plot to whatever time you want
saturationPoint = .95; # Percent coverage I'll plot to
# Create crater list
craters = [Crater(x, y, r)]
# Start up the color thing
cms = matplotlib.cm
mycolorind = 0.0004;
mycolor = cms.jet(mycolorind)
# mycolor = '#FF0000'
# Creating plot info
fig1 = plt.figure(figsize=(10,10))
ax = fig1.gca()
plt.xlim([0, 500])
plt.ylim([0,500])
# These are for some line plots later
numcraters = [1];
acovered = [craters[0].area]
while  not checkSaturation(craters, 500*500, saturationPoint)[0]:
  # r = 5; # km
  r = np.random.exponential(scale=4)+5 # km
  # Generate a random location
  x = np.random.rand()*500
  y = np.random.rand()*500
  # Update the crater list
  newCrater = Crater(x, y, r)
  reduceAll(craters, newCrater)
  removeNonExist(craters)
  craters.append(newCrater)
  # This is janky but the crater list updates every time by removing craters
  # that have been covered. So this should work
  numcraters.append(len(craters))
  acovered.append(checkSaturation(craters, 500*500, saturationPoint)[1])
  # Plot the crater
  circle = plt.Circle((x, y), r, color=mycolor)
  mycolorind += 0.0004
  # I want the craters to be different colors to discern time of impact better
  if math.isclose(mycolorind, 1.0):
    mycolorind = 0.0004
  # Another big slow downer. It's just so hard to see when they're not colorful
  mycolor = cms.jet(mycolorind)
  ax.add_patch(circle)
  t += 1 # Add 1000 years when one crater hits
fig1.savefig('testcirc')
print(t)

# I used this to help me figure out where to call it saturated
fig2, ax2 = plt.subplots()
# Time only incremented by one for every iteration so there's no need to make a 
# time list variable
plt.scatter(range(np.shape(acovered)[0]), acovered)
# Add the labels
plt.hlines(500*500, 0, t, linestyles='dashed')
plt.title('Area Covered by Impacts vs. Time')
plt.xlabel('Time (1000 years)')
plt.ylabel('Area covered (square km)')

### THIS SECTION is for plotting the total number of craters over time
fig3, ax3 = plt.subplots()
# Use the same time thing as before. I'll say it. This code is pretty bad.
plt.scatter(range(np.shape(acovered)[0]), numcraters)
plt.vlines(2200, 0, 1400, linestyles='dashed')
# Add the labels
plt.title('Number of Craters vs. Time')
plt.xlabel('Time (1000 years)')
plt.ylabel('Number of Craters')
print(max(numcraters))